from pathlib import Path
import json
import re
import argparse
import os

try:
    from yowasp_yosys import run_yosys
    YOWASP_AVAILABLE = True
except ImportError:
    YOWASP_AVAILABLE = False
    print("Warning: YOWASP not available, tool will call yosys directly.")

class Port:
    INPUT = "input"
    OUTPUT = "output"
    BIDIRECTIONAL = "bidirectional"

    def __init__(self, name: str, direction: str, bits: list[int]):
        self.name = name
        match direction:
            case Port.INPUT:
                self.direction = Port.INPUT
            case Port.OUTPUT:
                self.direction = Port.OUTPUT
            case Port.BIDIRECTIONAL:
                self.direction = Port.BIDIRECTIONAL
            case _:
                raise ValueError(f"Unknown port direction: {direction}")

        self.bits = sorted(bits)

    def __str__(self):
        return f"Port(name={self.name}, direction={self.direction}, bits={self.bits})"
    
    def __repr__(self):
        return str(self)

class Module:
    def __init__(self, name: str, config: dict):
        self.name = name
        self.config = config
        self.input_ports = []
        self.output_ports = []

        self._parse()

    def _parse(self):
        ports = self.config.get("ports", [])
        if not ports:
            raise ValueError(f"No ports found in module {self.name}")

        parsed_ports = []
        for port_name, port_details in ports.items():
            direction = port_details.get("direction", "unknown")
            bits = port_details.get("bits", [])
            parsed_ports.append(Port(port_name, direction, bits))

        parsed_ports.sort(key=lambda p: min(p.bits))

        bus_port_pattern = re.compile(r"(?P<signal_name>[\w_]+)_(?P<bit_index>\d+)")
        buses = {}
        for port in parsed_ports:
            # There can be multiple ports for one bus
            # The naming scheme would be the following:
            # <signal_name_with_underscores>_<bit_index>_
            match = bus_port_pattern.match(port.name)
            if match:
                signal_name = match.group("signal_name")
                bit_index = int(match.group("bit_index"))
                if signal_name not in buses:
                    buses[signal_name] = []
                buses[signal_name].append((bit_index, port))
            else:
                buses[port.name] = [(0, port)]

        parsed_ports = []
        for bus_name, bus_ports in buses.items():
            # print(f"{bus_name}:\t{len(bus_ports)} ports")
            bits = []
            for bit_index, port in bus_ports:
                # print(f"\tBit {bit_index}: {port}")
                for bit in port.bits:
                    bits.append(bit)
            parsed_ports.append(Port(bus_name, bus_ports[0][1].direction, bits))

        self.input_ports = [p for p in parsed_ports if p.direction == Port.INPUT]
        self.output_ports = [p for p in parsed_ports if p.direction == Port.OUTPUT]

    def get_xschem_symbol(self, width: float = 240):
        s  = "v {xschem version=3.4.7 file_version=1.2}\n"
        s += "G {}\n"
        s += "K {\n"
        s += "  type=primitive\n"
        s += "  format=\"@name [ " + " ".join(f"@@{p.name}{'' if not (len(p.bits) > 1) else f'[{len(p.bits)-1}..0]'}" for p in self.input_ports) + " ] [ " + " ".join(f"@@{p.name}{'' if not (len(p.bits) > 1) else f'[{len(p.bits)-1}..0]'}" for p in self.output_ports) + " ] @model\"\n"
        s += f"  template=\"name=A1 model={self.name} device_model={'\\' * 2}\".model {self.name} d_cosim simulation={'\\' * 6}\"ivlng{'\\' * 6}\" sim_args=[{'\\' * 6}\"{self.name}{'\\' * 6}\"]{'\\' * 2}\"\"\n"
        s += "\n"
        s += "  * Generated by XSCHEM Symbol Generator\n"
        s += "  *   Cedric Hirschi, ETH Zurich 2025\n"
        s += f"  * Generated for module '{self.name}'\n"
        s += "}\n"
        s += "V {}\n"
        s += "S {}\n"
        s += "E {}\n"
        s += "\n"
        s += "\n"
        
        x_coord = -width / 2
        if x_coord % 20 != 0:
            raise ValueError(f"width must be a multiple of 40, got {x_coord}")
        for i, port in enumerate(self.input_ports):
            y_coord = i * 20
            s += f"B 5 {x_coord-2.5} {y_coord - 2.5} {x_coord+2.5} {y_coord + 2.5}\t{{name={port.name}\tdir=inout}}\n"
            s += f"L 4 {x_coord} {y_coord} {x_coord+20} {y_coord} {{}}\n"
            s += f"T {{{port.name}}} {x_coord+25} {y_coord} 0 0 0.25 0.25 {{vcenter=true}}\n"
            s += "\n"
        s += "\n"
        
        x_coord = width / 2
        for i, port in enumerate(self.output_ports):
            y_coord = i * 20
            s += f"B 5 {x_coord-2.5} {y_coord - 2.5} {x_coord+2.5} {y_coord + 2.5}\t{{name={port.name}{"" if not (len(port.bits) > 1) else f"[{len(port.bits)-1}..0]"}\tdir=out}}\n"
            s += f"L 4 {x_coord-20} {y_coord} {x_coord} {y_coord} {{}}\n"
            s += f"T {{{port.name}{"" if not (len(port.bits) > 1) else f"[{len(port.bits)-1}..0]"}}} {x_coord-25} {y_coord} 2 0 0.25 0.25 {{vcenter=true}}\n"
            s += "\n"
        s += "\n"
        
        max_pins_per_side = max(len(self.input_ports), len(self.output_ports))
        s += f"B 4 {-x_coord+20} -20 {x_coord-20} {max_pins_per_side*20} {{fill=false}}\n"
        s += f"T {{@symname}} {-x_coord+20} -40 2 1 0.3 0.3 {{vcenter=true}}\n"
        s += f"T {{@name}} {-x_coord+20} -60 2 1 0.3 0.3 {{vcenter=true}}\n"

        return s

if __name__ == "__main__":
    ap = argparse.ArgumentParser(description="Generate XSCHEM symbol from Verilog module.")
    ap.add_argument("input", help="Path to the input Verilog file.")
    ap.add_argument("--output", default=None, help="Path to the output XSCHEM symbol file.")
    ap.add_argument("--top", default=None, help="Name of the top module to generate the symbol for. First module in the file by default.")
    ap.add_argument("--width", type=float, default=240, help="Width of the symbol.")
    args = ap.parse_args()

    pwd = Path().resolve()

    json_script_file = pwd / "_gen_json.ys"
    json_file = pwd / "_gen.json"
    input_file = Path(args.input).resolve()

    if not input_file.exists():
        print(f"Error: Input file not found: '{input_file.as_posix()}'")
        exit(1)

    with open(json_script_file, "w") as f:
        f.write(f"read_verilog -sv {input_file.as_posix()}\n")
        f.write("hierarchy -top adc\n")
        f.write("proc\n")
        f.write(f"write_json {json_file.as_posix()}\n")

    if YOWASP_AVAILABLE:
        result = run_yosys(["-q", json_script_file.as_posix()]) # type: ignore
    else:
        result = os.system(f"yosys -q {json_script_file.as_posix()}")
    
    json_script_file.unlink()
    
    if result != 0:
        exit(1)

    if not json_file.exists():
        print(f"Yosys did not generate '{json_file.as_posix()}'\n")
        exit(1)

    with open(json_file, "r") as f:
        data = json.load(f)

    modules = data.get("modules", [])
    if not modules:
        print(f"Error: No modules found in '{input_file.as_posix()}'\n")
        exit(1)

    top_module_name = args.top or list(modules.keys())[0]
    if top_module_name not in modules:
        print(f"Error: Top module not found: '{top_module_name}'\n       Available modules: {list(modules.keys())}")
        exit(1)
    top_module = Module(top_module_name, modules[top_module_name])

    output_file = Path(args.output or f"{top_module.name}.sym").resolve()
    if output_file.exists():
        answer = input(f"\nOutput file '{output_file.as_posix()}' already exists!\n  Overwrite? [Y/n] ")
        if answer.lower() == "n":
            print("Exiting without overwriting the output file.")
            exit(0)

    with open(output_file, "w") as f:
        f.write(top_module.get_xschem_symbol(args.width))
    print(f"\nXSCHEM symbol generated: '{output_file.as_posix()}'")
